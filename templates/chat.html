<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Codex Chat Monitor</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background: #0b0d10; color: #e6edf3; }
      header { padding: 12px 16px; background: #11161c; border-bottom: 1px solid #1f2937; display:flex; align-items:center; gap:8px; flex-wrap: wrap; }
      select, button, input[type=text], input[type=range] { background:#0f172a; color:#e6edf3; border:1px solid #334155; padding:6px 8px; border-radius:6px; }
      input#sessionName { min-width: 180px; }
      button:hover { background:#111827; cursor:pointer; }
      #stats { margin-left:auto; font-size:12px; opacity:.8 }
      #chat { padding: 12px 16px; height: calc(100vh - 140px); overflow-y: auto; box-sizing: border-box; }
      #compose { display:flex; gap:8px; align-items:center; padding: 8px 16px 12px; border-top: 1px solid #1f2937; background:#0b0d10; position: sticky; bottom: 0; }
      #msgBox { flex: 1; }
      .msg { max-width: 70%; margin: 8px 0; padding: 10px 12px; border-radius: 10px; line-height: 1.4; white-space: pre-wrap; box-shadow: 0 8px 18px rgba(0,0,0,0.18); }
      .msg.user { background: #1f2937; border-top-left-radius: 4px; }
      .msg.ai { background: linear-gradient(135deg, #0d3b66, #1d4f91); border-top-left-radius: 4px; }
      .msg.system { background: #f3e5f5; color: #2d0b45; border-left: 4px solid #9c27b0; }
      .msg.error { background: #ffebee; color: #5f2120; border-left: 4px solid #f44336; }
      .meta { font-size: 11px; opacity: 0.75; margin-bottom: 4px; display:flex; align-items:center; gap:6px; }
      .meta .timestamp { font-variant-numeric: tabular-nums; }
      .right { margin-left: auto; text-align: right; }
      .left  { margin-right: auto; text-align: left; }
      .row { display:flex; flex-direction: column; }

      /* Error notification styles */
      .error-notification { position: fixed; top: 20px; right: 20px; max-width: 400px; background: #ff5c5c; color: #fff; border-radius: 10px; box-shadow: 0 12px 28px rgba(0, 0, 0, 0.4); z-index: 1100; transform: translateX(120%); transition: transform 0.3s ease-in-out; backdrop-filter: blur(6px); }
      .error-notification.show { transform: translateX(0); }
      .error-notification.hidden { display: none; }
      .error-content { display: flex; padding: 16px 18px; align-items: flex-start; gap: 12px; }
      .error-icon { font-size: 26px; flex-shrink: 0; }
      .error-details { flex: 1; }
      .error-message { font-weight: 600; margin-bottom: 4px; letter-spacing: 0.01em; }
      .error-recovery { font-size: 14px; opacity: 0.9; margin-bottom: 4px; }
      .error-code { font-size: 12px; opacity: 0.75; font-family: "JetBrains Mono", "Fira Code", monospace; }
      .error-dismiss { background: rgba(255,255,255,0.14); border: none; color: inherit; font-size: 20px; cursor: pointer; padding: 0; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; border-radius: 6px; flex-shrink: 0; transition: background 0.2s ease; }
      .error-dismiss:hover { background: rgba(255,255,255,0.3); }

      /* System status indicator */
      .system-status { position: fixed; bottom: 20px; right: 20px; display: flex; align-items: center; gap: 8px; background: rgba(15, 23, 42, 0.85); color: #fff; padding: 8px 14px; border-radius: 24px; font-size: 13px; z-index: 1050; box-shadow: 0 8px 20px rgba(0,0,0,0.35); backdrop-filter: blur(4px); }
      .status-indicator { width: 10px; height: 10px; border-radius: 50%; background: #22c55e; animation: pulse 2s infinite; }
      .status-indicator.error { background: #ef4444; }
      .status-indicator.warning { background: #f59e0b; }
      .status-text { letter-spacing: 0.02em; }
      @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.6; transform: scale(1.1); } }

      /* Loading indicator */
      .loading-indicator { display: inline-flex; align-items: center; gap: 8px; color: #9ca3af; font-style: italic; }
      .loading-dots { display: inline-flex; gap: 3px; }
      .loading-dots span { width: 6px; height: 6px; background: #9ca3af; border-radius: 50%; animation: loading-bounce 1.4s infinite ease-in-out both; }
      .loading-dots span:nth-child(1) { animation-delay: -0.32s; }
      .loading-dots span:nth-child(2) { animation-delay: -0.16s; }
      @keyframes loading-bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1); } }
    </style>
  </head>
  <body>
    <div id="error-notification" class="error-notification hidden">
      <div class="error-content">
        <div class="error-icon">⚠️</div>
        <div class="error-details">
          <div class="error-message"></div>
          <div class="error-recovery"></div>
          <div class="error-code"></div>
        </div>
        <button class="error-dismiss" onclick="dismissError()">×</button>
      </div>
    </div>
    <div id="system-status" class="system-status">
      <div class="status-indicator" id="status-indicator"></div>
      <span class="status-text" id="status-text">Connecting…</span>
    </div>

    <header>
      <strong>Codex Chat Monitor</strong>
      <label for="sessionSel" style="margin-left:8px">Session:</label>
      <select id="sessionSel"></select>
      <input id="sessionName" type="text" placeholder="Friendly name" />
      <button id="saveNameBtn" title="Save friendly name">Save Name</button>
      <button id="loadBtn">Load</button>
      <button id="newBtn">New</button>
      <button id="deleteBtn" title="Delete current session">Delete</button>
      <button id="refreshBtn">Refresh</button>
      <button id="copyIdBtn" title="Copy current session ID">Copy SysID</button>
      <span id="stats"></span>
    </header>
    <div id="chat"></div>
    <div id="compose">
      <label for="fromId">From:</label>
      <input id="fromId" type="text" placeholder="sender id (e.g., brent)" value="brent" style="width:140px" />
      <input id="msgBox" type="text" placeholder="Type a message." />
      <label style="display:flex; align-items:center; gap:6px; font-size:12px; opacity:.9"> <input id="autoReply" type="checkbox" checked /> Ask Codex to reply</label>
      
      <label style="display:flex; align-items:center; gap:6px; font-size:12px; opacity:.9"> Last <span id="limitLabel">100</span> <input id="limitRange" type="range" min="10" max="500" step="10" value="100" /></label>
      <button id="sendBtn">Send</button>
    </div>
    <script>
      const sel = document.getElementById('sessionSel');
      const chat = document.getElementById('chat');
      const stats = document.getElementById('stats');
      const sessionNameInput = document.getElementById('sessionName');
      const saveNameBtn = document.getElementById('saveNameBtn');
      const statusIndicator = document.getElementById('status-indicator');
      const statusText = document.getElementById('status-text');
      const errorNotification = document.getElementById('error-notification');
      
      const limitRange = document.getElementById('limitRange');
      const limitLabel = document.getElementById('limitLabel');
      let current = null;
      let timer = null;
      let viewLimit = 100;
      let isAtBottom = true; // track if user is at (or near) bottom
      let currentErrorTimeout = null;
      let sessionMetadata = {};
      let isEditingName = false;

      function updateSystemStatus(state, text) {
        statusIndicator.classList.remove('error', 'warning');
        if (state === 'error') {
          statusIndicator.classList.add('error');
        } else if (state === 'warning') {
          statusIndicator.classList.add('warning');
        }
        statusText.textContent = text;
      }

      function dismissError() {
        errorNotification.classList.remove('show');
        if (currentErrorTimeout) {
          clearTimeout(currentErrorTimeout);
          currentErrorTimeout = null;
        }
        setTimeout(() => {
          errorNotification.classList.add('hidden');
        }, 250);
        setTimeout(() => updateSystemStatus('connected', 'Connected'), 1500);
      }

      function showError({ title, message, recovery, code }) {
        const messageEl = errorNotification.querySelector('.error-message');
        const recoveryEl = errorNotification.querySelector('.error-recovery');
        const codeEl = errorNotification.querySelector('.error-code');

        messageEl.textContent = title || message || 'An error occurred';
        recoveryEl.textContent = recovery || '';
        codeEl.textContent = code ? `Code: ${code}` : '';

        errorNotification.classList.remove('hidden');
        requestAnimationFrame(() => errorNotification.classList.add('show'));

        if (currentErrorTimeout) {
          clearTimeout(currentErrorTimeout);
        }
        currentErrorTimeout = setTimeout(dismissError, 10000);
        updateSystemStatus('error', 'Error encountered');
      }

      function addLoadingMessage(label = 'Codex is thinking') {
        removeLoadingMessage();
        const messagesDiv = document.getElementById('chat');
        const loadingDiv = document.createElement('div');
        loadingDiv.className = 'row';
        loadingDiv.id = 'loading-row';
        loadingDiv.innerHTML = `
          <div class="meta left"><span class="timestamp">${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span></div>
          <div class="msg system loading-message">
            <div class="loading-indicator">
              <span>${label}</span>
              <div class="loading-dots"><span></span><span></span><span></span></div>
            </div>
          </div>
        `;
        messagesDiv.appendChild(loadingDiv);
        messagesDiv.scrollTop = messagesDiv.scrollHeight;
        return loadingDiv;
      }

      function removeLoadingMessage() {
        const loadingRow = document.getElementById('loading-row');
        if (loadingRow) {
          loadingRow.remove();
        }
      }

      async function listSessions() {
        try {
          const r = await fetch('/sessions');
          if (!r.ok) {
            const data = await r.json().catch(() => ({}));
            showError({
              title: data.message || 'Unable to load sessions',
              recovery: data.recovery || 'Refresh and try again',
              code: data.code || 'LIST_SESSIONS_ERROR'
            });
            return false;
          }
          const j = await r.json();
          sel.innerHTML = '';
          sessionMetadata = {};
          (j.sessions || []).forEach(s => {
            sessionMetadata[s.session_id] = s;
            const friendly = (s.display_name && s.display_name.trim()) || `${s.session_id.slice(0,8)}…`;
            const option = document.createElement('option');
            option.value = s.session_id;
            option.textContent = `${friendly} (${s.messages} msgs, ${s.token_usage} tok)`;
            sel.appendChild(option);
          });
          if (current && [...sel.options].some(o => o.value === current)) {
            sel.value = current;
          }
          if (!isEditingName && current && sessionMetadata[current]) {
            sessionNameInput.value = sessionMetadata[current].display_name || '';
          }
          return true;
        } catch (e) {
          console.error('listSessions failed', e);
          showError({ title: 'Unable to load sessions', recovery: 'Check connection and retry', code: 'LIST_SESSIONS_ERROR' });
          return false;
        }
      }
      function renderMessages(items, preserveScroll=false) {
        // track scroll state for smart auto-scroll
        const prevScrollTop = chat.scrollTop;
        const prevScrollHeight = chat.scrollHeight;
        chat.innerHTML = '';
        (items || []).forEach(m => {
          const row = document.createElement('div'); row.className = 'row';
          const meta = document.createElement('div'); meta.className = 'meta left';
          const speaker = m.ai_id ? m.ai_id : (m.from === 'ai' ? 'codex' : (m.from || 'user'));
          meta.innerHTML = `<strong>${speaker}</strong><span class="timestamp">${formatTimestamp(m.ts || '')}</span>`;
          const type = m.from === 'ai' ? 'ai' : (m.from === 'system' ? 'system' : 'user');
          const bubble = document.createElement('div');
          bubble.className = `msg ${type} left`;
          bubble.textContent = m.content || '';
          row.appendChild(meta); row.appendChild(bubble); chat.appendChild(row);
        });
        if (preserveScroll) {
          const delta = chat.scrollHeight - prevScrollHeight;
          chat.scrollTop = prevScrollTop + Math.max(0, delta);
        } else {
          chat.scrollTop = chat.scrollHeight;
        }
        // update bottom flag after render
        isAtBottom = shouldAutoScroll();
      }

      function shouldAutoScroll() {
        const threshold = 4; // px from bottom (tighter for precision)
        return (chat.scrollTop + chat.clientHeight) >= (chat.scrollHeight - threshold);
      }

      function formatTimestamp(isoString) {
        if (!isoString) return '';
        // Normalize ISO microseconds to milliseconds for broad JS Date compatibility
        let s = String(isoString);
        s = s.replace(/\.(\d{3})\d+(?=[Z+-])/, '.$1'); // trim fractional seconds to 3 digits
        const date = new Date(s);
        if (isNaN(date.getTime())) return '';
        const now = new Date();
        const isToday = date.toDateString() === now.toDateString();
        if (isToday) {
          return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        } else {
          return date.toLocaleString([], { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
        }
      }

      async function loadSelected() {
        const id = sel.value; if (!id) return;
        current = id;
        const atBottom = isAtBottom;
        try {
          const r = await fetch(`/sessions/${id}/messages?limit=${viewLimit}`);
          if (!r.ok) {
            const data = await r.json().catch(() => ({}));
            showError({
              title: data.message || 'Failed to load session messages',
              recovery: data.recovery || 'Please refresh and try again',
              code: data.code,
            });
            return;
          }
          const j = await r.json();
          if (!isEditingName) {
            sessionNameInput.value = j.display_name || '';
          }
          if (!sessionMetadata[current]) {
            sessionMetadata[current] = { session_id: current };
          }
          sessionMetadata[current].display_name = j.display_name || '';
          renderMessages(j.messages, !atBottom);
          stats.textContent = `${j.messages.length} msgs · ${j.token_usage} tokens`;
        } catch (e) {
          console.error('loadSelected failed', e);
          showError({ title: 'Unable to load messages', recovery: 'Check your connection and retry', code: 'LOAD_MESSAGES_ERROR' });
        }
      }

      async function createNew() {
        updateSystemStatus('warning', 'Creating session…');
        try {
          const payload = { ai_ids: ['codex'] };
          const desiredName = (sessionNameInput.value || '').trim();
          if (desiredName) {
            payload.display_name = desiredName;
          }
          const r = await fetch('/sessions', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(payload) });
          const data = await r.json();
          if (!r.ok || !data.session) {
            showError({ title: data.message || 'Failed to create session', recovery: data.recovery || 'Try again', code: data.code });
            return;
          }
          current = data.session.session_id;
          const listed = await listSessions();
          if (!listed) {
            updateSystemStatus('warning', 'Session created but list unavailable');
          } else {
            sel.value = current;
            await loadSelected();
          }
          isEditingName = false;
          sessionNameInput.value = data.session.display_name || desiredName || '';
          addMessage('System', `Session created: ${current}`, 'system');
          updateSystemStatus('connected', 'Connected');
        } catch (e) {
          console.error('createNew failed', e);
          showError({ title: 'Failed to create session', recovery: 'Check connection and retry', code: 'SESSION_CREATE_ERROR' });
        }
      }

      document.getElementById('loadBtn').onclick = loadSelected;
      document.getElementById('newBtn').onclick = createNew;
      sel.addEventListener('change', () => {
        isEditingName = false;
        const meta = sessionMetadata[sel.value] || {};
        sessionNameInput.value = meta.display_name || '';
      });
      document.getElementById('refreshBtn').onclick = async () => { await listSessions(); await loadSelected(); };
      document.getElementById('deleteBtn').onclick = async () => {
        if (!current) {
          showError({ title: 'No session selected', recovery: 'Pick a session first', code: 'NO_SESSION' });
          return;
        }
        const confirmed = confirm('Delete this session and all messages?');
        if (!confirmed) {
          return;
        }
        updateSystemStatus('warning', 'Deleting session…');
        try {
          const response = await fetch(`/sessions/${current}`, { method: 'DELETE' });
          if (!response.ok) {
            const data = await response.json().catch(() => ({}));
            showError({ title: data.message || 'Failed to delete session', recovery: data.recovery || 'Try again', code: data.code });
            return;
          }
          current = null;
          chat.innerHTML = '';
          stats.textContent = '';
          sessionNameInput.value = '';
          await listSessions();
          updateSystemStatus('connected', 'Session deleted');
        } catch (e) {
          console.error('delete session failed', e);
          showError({ title: 'Delete failed', recovery: 'Check connection and retry', code: 'DELETE_SESSION_ERROR' });
        }
      };

      saveNameBtn.onclick = async () => {
        if (!current) {
          showError({ title: 'No session selected', recovery: 'Select a session first', code: 'NO_SESSION' });
          return;
        }
        const desiredName = sessionNameInput.value.trim();
        try {
          updateSystemStatus('warning', 'Saving name…');
          const response = await fetch(`/sessions/${current}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ display_name: desiredName })
          });
          const data = await response.json().catch(() => ({}));
          if (!response.ok) {
            showError({ title: data.message || 'Failed to save name', recovery: data.recovery || 'Try again', code: data.code });
            return;
          }
          await listSessions();
          sel.value = current;
          isEditingName = false;
          sessionNameInput.value = data.session?.display_name || desiredName;
          updateSystemStatus('connected', 'Name saved');
        } catch (e) {
          console.error('save name failed', e);
          showError({ title: 'Could not save name', recovery: 'Check connection and retry', code: 'SAVE_NAME_ERROR' });
        }
      };

      sessionNameInput.addEventListener('focus', () => {
        isEditingName = true;
      });

      sessionNameInput.addEventListener('blur', () => {
        // Allow click handlers (e.g., Save) to read the value before toggling the flag
        setTimeout(() => { isEditingName = false; }, 0);
      });
      document.getElementById('copyIdBtn').onclick = async () => {
        const btn = document.getElementById('copyIdBtn');
        if (!current) { btn.textContent = 'No Session'; setTimeout(()=>btn.textContent='Copy SysID', 1000); return; }
        const text = current;
        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
          } else {
            const ta = document.createElement('textarea');
            ta.value = text; ta.style.position = 'fixed'; ta.style.opacity = '0';
            document.body.appendChild(ta); ta.focus(); ta.select();
            document.execCommand('copy'); document.body.removeChild(ta);
          }
          btn.textContent = 'Copied'; setTimeout(()=>btn.textContent='Copy SysID', 1200);
        } catch (e) {
          console.error('Copy failed', e);
          btn.textContent = 'Copy Failed'; setTimeout(()=>btn.textContent='Copy SysID', 1400);
        }
      };

      limitRange.addEventListener('input', () => {
        viewLimit = parseInt(limitRange.value, 10) || 100;
        limitLabel.textContent = String(viewLimit);
      });
      limitRange.addEventListener('change', loadSelected);

      async function sendMessage() {
        if (!current) { await createNew(); }
        const fromId = document.getElementById('fromId').value.trim() || 'brent';
        const box = document.getElementById('msgBox');
        const auto = document.getElementById('autoReply').checked;
        const text = box.value.trim();
        if (!text) return;
        const btn = document.getElementById('sendBtn');
        btn.disabled = true; btn.textContent = 'Sending…';
        const addedLoading = auto ? addLoadingMessage() : null;
        updateSystemStatus('warning', 'Sending message…');
        try {
          if (auto) {
            const response = await fetch('/chat-with-codex', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', 'X-AI-Id': fromId },
              body: JSON.stringify({ message: text, session_id: current })
            });
            const data = await response.json().catch(() => ({}));
            removeLoadingMessage();
            if (!response.ok) {
              showError({ title: data.message || 'Request failed', recovery: data.recovery || 'Try again in a bit', code: data.code });
              addMessage('System', data.message || 'Codex could not process that request.', 'error');
            } else {
              await loadSelected();
              updateSystemStatus('connected', 'Connected');
            }
          } else {
            const response = await fetch(`/sessions/${current}/messages`, {
              method: 'POST', headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ from: 'user', content: text, ai_id: fromId })
            });
            if (!response.ok) {
              const data = await response.json().catch(() => ({}));
              showError({ title: data.message || 'Failed to add message', recovery: data.recovery || 'Please try again', code: data.code });
            }
            await loadSelected();
            updateSystemStatus('connected', 'Connected');
          }
          box.value = '';
        } catch (e) {
          console.error('sendMessage failed', e);
          removeLoadingMessage();
          showError({ title: 'Connection failed', recovery: 'Check your connection and retry', code: 'NETWORK_ERROR' });
          addMessage('System', 'Connection error - please try again', 'error');
        } finally {
          btn.disabled = false; btn.textContent = 'Send';
          if (addedLoading) {
            removeLoadingMessage();
          }
        }
      }

      document.getElementById('sendBtn').onclick = sendMessage;
      document.getElementById('msgBox').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
      });

      // Track user scroll position to decide auto-scroll behavior
      chat.addEventListener('scroll', () => {
        isAtBottom = shouldAutoScroll();
      });

      async function checkSystemHealth() {
        try {
          const response = await fetch('/healthz');
          if (response.ok) {
            updateSystemStatus('connected', 'Connected');
          } else {
            updateSystemStatus('warning', 'Service issues');
          }
        } catch (e) {
          updateSystemStatus('error', 'Connection lost');
        }
      }

      (async () => {
        updateSystemStatus('warning', 'Loading sessions…');
        await listSessions();
        if (sel.options.length) { sel.selectedIndex = 0; current = sel.value; await loadSelected(); }
        timer = setInterval(loadSelected, 3000);
        setInterval(checkSystemHealth, 30000);
        await checkSystemHealth();
        updateSystemStatus('connected', 'Connected');
      })();
    </script>
  </body>
  </html>
